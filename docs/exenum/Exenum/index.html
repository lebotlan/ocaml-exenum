<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Exenum (exenum.Exenum)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../index.html">exenum</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Exenum</span></h1></header><h3>Build efficient enumerations for datatypes</h3><p>The exenum library offers constructors to build enumerations for datatypes, that is, functions
from (arbitrarily large) integers to values. Such enumerations are very useful for unit testing.</p><p>The library is efficient: the n-th element of an enumeration
is returned without having computed the (n-1) previous elements.
Complexity is in log(n), except for some pathological datatypes.</p><p>Homepage: <a href="https://github.com/lebotlan/ocaml-exenum">https://github.com/lebotlan/ocaml-exenum</a></p><p><i>Inspired by Feat: Functional Enumeration of Algebraic Types, by Duregard, Jansson, Wang, Chalmers University.</i></p><p><i>Contact: D. Le Botlan (github.lebotlan@dfgh.met where you replace .met by .net.)</i></p><h4>Example</h4><p>As an example, consider the following familiar datatype:
</p><pre><code class="code">type term = Var of string | App of term * term | Lambda of string * term</code></pre><p>
Using exenum, one may easily generate zillions of different lambda-terms.
For this example, we limit ourselves to four variable names : x, y, u, and v.
Then, one may compute for instance term number 2000000000000, which happens to be
</p><pre>((((x v) (fun u -&gt; y)) ((fun u -&gt; y) (fun y -&gt; y))) (((x v) (fun u -&gt; v)) (fun u -&gt; y)))</pre><p>Building an enumeration from a datatype is straightforward. For instance, the enumeration corresponding to type <code class="code">term</code> is
built as follows:
</p><pre><code class="code">(* We restrict ourselves to four variable names. *)
let e_vars = from_list ~name:&quot;variables&quot; [&quot;x&quot; ; &quot;y&quot; ; &quot;u&quot; ; &quot;v&quot;]

(* Type term is recursive, hence we need a lazy enumeration first. *)
let rec e_term = lazy
  begin
    (* In order to use the enumeration recursively, we need to &quot;pay&quot; a recursive fee. *)
    let r_term = pay e_term in
   
    (* Now, this is the direct translation of the datatype definition. *)
    union 
      [ map e_vars (fun x -&gt; Var x) ;
        map (pair r_term r_term) (fun (t1, t2) -&gt; App (t1, t2)) ;
        map (pair e_vars r_term) (fun (x, t) -&gt; Lambda (x, t))  ] 
  end

(* Here is the enumeration for lambda-terms. *)
let e_term = Lazy.force e_term</code></pre><p>See examples in <a href="https://github.com/lebotlan/ocaml-exenum/tree/master/examples">https://github.com/lebotlan/ocaml-exenum/tree/master/examples</a></p><div class="spec type" id="type-enum"><a href="#type-enum" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a enum</code><code></code><code></code></div><div class="doc"><p>The type of exhaustive enumerations of values of type 'a.
Enumerations can be finite of infinite.</p></div></div><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a t</code><code><span class="keyword"> = </span><span class="type-var">'a</span> <a href="index.html#type-enum">enum</a></code><code></code></div><div class="doc"></div></div><h4>Basics</h4><div class="spec val" id="val-from_list"><a href="#val-from_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>from_list : ?&#8288;name:string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Builds a finite enumeration from a finite set of values.
The name is used for nicer debugging.</p></div></div><div class="spec val" id="val-single"><a href="#val-single" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>single : ?&#8288;name:string <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Enumeration of a single value (derived from <a href="index.html#val-from_list">from_list</a>).</p></div></div><div class="spec val" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cardinal : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Z.t option</code></div><div class="doc"><p><code class="code">cardinal enum</code> Returns the cardinality of <code class="code">enum</code>. None means infinity.</p></div></div><div class="spec val" id="val-get"><a href="#val-get" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Z.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p><code class="code">get enum n</code> Returns the nth value of type 'a, starting at 0.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Failure</span>: if <code class="code">n</code> is greater or equal than the cardinality of <code class="code">enum</code>.</li></ul></div></div><h4>Finite enumerations for ground types</h4><div class="spec val" id="val-e_unit"><a href="#val-e_unit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_unit : unit <a href="index.html#type-t">t</a></code></div><div class="doc"><p>One element: ().</p></div></div><div class="spec val" id="val-e_bool"><a href="#val-e_bool" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_bool : bool <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Two elements: true, false</p></div></div><div class="spec val" id="val-e_char"><a href="#val-e_char" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_char : char <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Contains 256 elements: from '\000' to '\255'.</p></div></div><div class="spec val" id="val-e_pchar"><a href="#val-e_pchar" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_pchar : char <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Printable characters (from 32 to 125).</p></div></div><div class="spec val" id="val-e_biginterval"><a href="#val-e_biginterval" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_biginterval : Z.t <span class="keyword">&#8209;&gt;</span> Z.t <span class="keyword">&#8209;&gt;</span> Z.t <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Enumeration of a big-integer interval.</p></div></div><div class="spec val" id="val-e_interval"><a href="#val-e_interval" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_interval : int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Enumeration of an integer interval.</p></div></div><div class="spec val" id="val-sub"><a href="#val-sub" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sub : max:Z.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">sub ~max enum</code> Returns a finite enumeration with at most <code class="code">max</code> elements.</p></div></div><h4>Infinite enumerations for ground types</h4><p>For these enumerations of integers, do not expect the n-th value to be equal to the integer n. Integers are shuffled.</p><div class="spec val" id="val-e_bigpos"><a href="#val-e_bigpos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_bigpos : Z.t <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Strictly positive numbers: [1, +infty[</p></div></div><div class="spec val" id="val-e_bignat"><a href="#val-e_bignat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_bignat : Z.t <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Natural numbers: [0, +infty[</p></div></div><div class="spec val" id="val-e_bigint"><a href="#val-e_bigint" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_bigint : Z.t <a href="index.html#type-t">t</a></code></div><div class="doc"><p>All numbers: ] -infty, +infty [
This enumeration starts from 0 and alternates between positive and negative values.</p></div></div><div class="spec val" id="val-e_nat"><a href="#val-e_nat" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_nat : int <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Natural integers: [0, max_int] as an infinite enumeration (hence, non-injective).</p></div></div><div class="spec val" id="val-e_pos"><a href="#val-e_pos" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_pos : int <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Strictly positive integers: [1, max_int] as an infinite enumeration (hence, non-injective).</p></div></div><div class="spec val" id="val-e_int"><a href="#val-e_int" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_int : int <a href="index.html#type-t">t</a></code></div><div class="doc"><p>All integers: [min_int, max_int].
This enumeration starts from 0 and alternates between positive and negative values.
This enumeration is infinite, hence non-injective.</p></div></div><div class="spec val" id="val-e_string"><a href="#val-e_string" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_string : string <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Strings, built only with printable characters.</p></div></div><div class="spec val" id="val-e_rstring"><a href="#val-e_rstring" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_rstring : char list <span class="keyword">&#8209;&gt;</span> string <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Strings, built only with the given characters.</p></div></div><h4>Composition</h4><div class="spec val" id="val-union"><a href="#val-union" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>union : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">union enums</code> builds an enumeration from a union of enumerations.
If <code class="code">enums</code> are disjoint enumerations, the resulting enumeration is injective.</p></div></div><div class="spec val" id="val-product"><a href="#val-product" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>product : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> list <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Builds an enumeration from a cartesian product of enumerations.</p></div></div><div class="spec val" id="val-pair"><a href="#val-pair" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pair : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Convenience function to build an enumeration of pairs from two enumerations (derived from product and projection functions).</p></div></div><div class="spec val" id="val-triple"><a href="#val-triple" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>triple : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-tuple2"><a href="#val-tuple2" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tuple2 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"><p>This is the same as <code class="code">pair</code></p></div></div><div class="spec val" id="val-tuple3"><a href="#val-tuple3" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tuple3 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"><p>This is the same as <code class="code">triple</code></p></div></div><div class="spec val" id="val-tuple4"><a href="#val-tuple4" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tuple4 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span><span class="keyword"> * </span><span class="type-var">'d</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-tuple5"><a href="#val-tuple5" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tuple5 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'e</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span><span class="keyword"> * </span><span class="type-var">'d</span><span class="keyword"> * </span><span class="type-var">'e</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-tuple6"><a href="#val-tuple6" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tuple6 : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'c</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'d</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'e</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'f</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span><span class="keyword"> * </span><span class="type-var">'b</span><span class="keyword"> * </span><span class="type-var">'c</span><span class="keyword"> * </span><span class="type-var">'d</span><span class="keyword"> * </span><span class="type-var">'e</span><span class="keyword"> * </span><span class="type-var">'f</span>) <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-e_list"><a href="#val-e_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Enumerations of lists of arbitrary size, starting from the empty list.</p></div></div><div class="spec val" id="val-e_ne_list"><a href="#val-e_ne_list" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_ne_list : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> list <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Enumerations of non-empty lists (see e_list).</p></div></div><div class="spec val" id="val-e_array"><a href="#val-e_array" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_array : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> array <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Enumerations of arrays.</p></div></div><div class="spec val" id="val-e_option"><a href="#val-e_option" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>e_option : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> option <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><h4>Recursion, map</h4><div class="spec val" id="val-pay"><a href="#val-pay" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>pay : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> Lazy.t <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>An enumeration is a possibly-infinite set of finite parts.
Recursive, infinite enumerations must be built by increasing the cost of each part.
The enumeration given in argument <b>must</b> be infinite (which is usually the case when building a recursive enumeration).
See examples to understand how to use <code class="code">pay</code>.</p></div></div><div class="spec val" id="val-map"><a href="#val-map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span>) <span class="keyword">&#8209;&gt;</span> <span class="type-var">'b</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Builds an enumeration by mapping an existing enumeration.</p></div></div><h4>Helper functions</h4><div class="spec val" id="val-show"><a href="#val-show" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>show : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">show enum to_string index len</code> outputs values of the given enumeration, using the <code class="code">to_string</code> conversion function,
from index index to index (index + len - 1).</p></div></div><div class="spec val" id="val-bigshow"><a href="#val-bigshow" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>bigshow : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> Z.t <span class="keyword">&#8209;&gt;</span> int <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">bigshow enum to_string index len</code> is similar to <code class="code">show</code>, except that index is a Z.t.</p></div></div><div class="spec val" id="val-tester"><a href="#val-tester" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>tester : <span class="type-var">'a</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> ?&#8288;from:Z.t <span class="keyword">&#8209;&gt;</span> ?&#8288;upto:Z.t <span class="keyword">&#8209;&gt;</span> ?&#8288;verbose_period:int <span class="keyword">&#8209;&gt;</span> ?&#8288;tos:(<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> string) <span class="keyword">&#8209;&gt;</span> len:int <span class="keyword">&#8209;&gt;</span> (<span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> unit) <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">tester enum ~len f</code> applies f in sequence to different values of the enumeration.
First, <code class="code">len</code> values are taken starting at 0 (or starting from <code class="code">from</code>, if specified).
Then, the current index is multiplied by 2 (that is, we start at 2*len) and again <code class="code">len</code> values are considered.
This is repeated forever (or while the current index is lower than the upper bound <code class="code">upto</code>).</p><p>If <code class="code">verbose_period</code> is strictly positive, a message giving the current index is printed on stdout every <code class="code">verbose_period</code> tests.
If tos is given, the test value is printed too.</p><p>Typical usage is: <code class="code">tester enum ~len:10000 f</code>, where f is a testing function.</p><ul class="at-tag"><li><span class="at-tag raise">Raises</span> <span class="module-path">Assert_failure</span>: if <code class="code">len &lt;= 0</code></li></ul></div></div></body></html>